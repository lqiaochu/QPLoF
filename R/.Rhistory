library(QPLoF)
## Parameter Settings
n = 200			# number of obsevations
p = 3			# number of covariates dimensions
l0 = 0.4			# start point of quantile interval
u0 = 0.6			# end point of quantile interval
tau_kn = 11			# number of grids for quantile interval
spline_kn = 5			# number of knots for B-splines
degree = 3			# order of B-splines
beta0 = c(1,2,1)			# initial coefficient vectors for beta
gamma0 = rep(1,p)			# initial coefficient vectors for gamma
B = 50			# bootstrap times (at least 1000 times, it's set to 50 just for testing)
v_index	= 1			# index of nonlinear functions
## Data generalization
e = rnorm(n,0,1)			# drawn from standard normal distribution
# Here we use example functions in gen_data_example.R in our package to generate preditor X and response y.
# preditor X is drawn from exponential distribution exp(1)
# preditor y is generated by an exponential nonlinear function
X = gen_x(n = n, p = p)
y = gen_y(x = X, beta0 = beta0, gamma0 = gamma0, e = epsilon, v = v_index)
tau = seq(l0,u0,length.out = tau_kn)			# quantile levels
breaks = seq(l0,u0,length.out = spline_kn)			# breaks for B-splines
n = 200			# number of obsevations
p = 3			# number of covariates dimensions
l0 = 0.4			# start point of quantile interval
u0 = 0.6			# end point of quantile interval
tau_kn = 11			# number of grids for quantile interval
spline_kn = 5			# number of knots for B-splines
degree = 3			# order of B-splines
beta0 = c(1,2,1)			# initial coefficient vectors for beta
gamma0 = rep(1,p)			# initial coefficient vectors for gamma
B = 50			# bootstrap times (at least 1000 times, it's set to 50 just for testing)
v_index	= 1			# index of nonlinear functions
## Data generalization
epsilon = rnorm(n,0,1)			# drawn from standard normal distribution
# Here we use example functions in gen_data_example.R in our package to generate preditor X and response y.
# preditor X is drawn from exponential distribution exp(1)
# preditor y is generated by an exponential nonlinear function
X = gen_x(n = n, p = p)
y = gen_y(x = X, beta0 = beta0, gamma0 = gamma0, e = epsilon, v = v_index)
tau = seq(l0,u0,length.out = tau_kn)			# quantile levels
breaks = seq(l0,u0,length.out = spline_kn)			# breaks for B-splines
Phi_tau = gen_bspline(tau = tau, breaks = breaks, degree = degree)
z_tau = kronecker(Phi_tau,X)
## optimization via MM algorithm
result = comp.B.MM.c(ztau = z_tau, Y = Y, tau = tau, breaks = breaks, basis.order = degree, n = n, p = p, maxiter=200, tol=10^-8, epsilon=0.01)
b_hat = as.vector(result$B)			# store the estimated coefficient matrix
e_hat = result$Residual			# store the estimated error
library(fda)
Phi_tau = gen_bspline(tau = tau, breaks = breaks, degree = degree)
z_tau = kronecker(Phi_tau,X)
## optimization via MM algorithm
result = comp.B.MM.c(ztau = z_tau, Y = Y, tau = tau, breaks = breaks, basis.order = degree, n = n, p = p, maxiter=200, tol=10^-8, epsilon=0.01)
b_hat = as.vector(result$B)			# store the estimated coefficient matrix
e_hat = result$Residual			# store the estimated error
## prepare for approximation
Phi_tau = gen_bspline(tau = tau, breaks = breaks, degree = degree)
z_tau = kronecker(Phi_tau,X)
## optimization via MM algorithm
result = comp.B.MM.c(ztau = z_tau, Y = y, tau = tau, breaks = breaks, basis.order = degree, n = n, p = p, maxiter=200, tol=10^-8, epsilon=0.01)
b_hat = as.vector(result$B)			# store the estimated coefficient matrix
e_hat = result$Residual			# store the estimated error
X = gen_x(n,p)
y = gen_y(X,beta0,gamma0,epsilon,v=v_index) #h0
Y = rep(y,length(tau))
Phi_tau = gen_bspline(tau,breaks,degree)
z_tau = kronecker(Phi_tau,X)
###### estimation #######
result = comp.B.MM.c(z_tau,Y,tau,breaks,degree,n,p,maxiter=200,tol=10^-8,epsilon=0.01)
library(devtools)
devtools::install_github("lqiaochu/QPLoF", force = TRUE)
devtools::install_github("lqiaochu/QPLoF", force = TRUE)
devtools::install_github("lqiaochu/QPLoF", force = TRUE)
